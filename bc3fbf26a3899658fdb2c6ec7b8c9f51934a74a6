{
  "comments": [
    {
      "key": {
        "uuid": "bfabb347_32cb02cf",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 46,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-11T18:10:50Z",
      "side": 1,
      "message": "This seems extreme, so I have to ask what is causing that? Is this an intermittent system (external to your jvm) latency, or are you seeing regular one minute loads for a fixed size of externalids? Approximately how much data (MB?) and how many users causes a 1 minute load? It is important to know what is causing such a long time if you want to be able to improve and eliminate this. For example: if this is intermittent random network delays, than only local node caches will solve this, and creating a git cache will not (because it may suffer from the same external factors).",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3281b35_e48cd1ab",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 46,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-12T12:44:16Z",
      "side": 1,
      "message": "This comes from the fact that we read a lot of data in small blocks, so basically network latency. This depends a bit on the storage, but reading 10s of thousands of entries in a NoteMap is wasteful regardless of the storage. One can make the argument that this is faster and less problematic if read from local FS, but the fact that a single update of a single external ID forces Gerrit to reload 10s of thousands of them is a design flaw that stands regardless. The impact might vary.",
      "parentUuid": "bfabb347_32cb02cf",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3dcdca8_3f2fa04a",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 46,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-12T19:31:32Z",
      "side": 1,
      "message": "Thanks. I would like to clarify that the current storage model (which I am by no means attached to BTW, I like your proposal better), does not dictate this problem, this is a coding problem. Because git has sha1s for every blob, it makes it easy to cache immutable values based on individual subsets of data from a ref (cache it by its blob sha1 instead of by the ref sha1). So even though all the current externalIds are on the same ref, they each are stored in their own blobs which can be accessed individually and cached based on the sha1d of those blobs, we just happen to not do that in Gerrit, so you are seeing the results of that.\n\nI want to point this out because I don\u0027t think we need indexes at the git level. I think that it is extra  complexity and I think it will slow things down because you need to update two refs at least for many updates. If you go with the proposed consolidation of all the primary data to the user\u0027s ref, then you can avoid any slowdowns to the BatchUpdateRef having to update indexes because you will only have one ref. This would completely avoid the whole concern of lock contention on updates in the future, and would fix the current contention that has been mentioned. I think that this could be very effectively backed by H2 persistent caches that get incrementally updated whenever a single user account is updated. These updates would generally be very cheap. This approach seems like it would be a big win for both simplicity and performance.  Would you agree that this would mean that the only times you would see a large cold startup hit is the first time you ever start your server, or if someone explicitly flushes those persistent caches? It sounds like that is the main driver for having the git indexes, trying to avoid the completely cold startup cost?",
      "parentUuid": "c3281b35_e48cd1ab",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea03e13e_1f546131",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 46,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-15T14:53:04Z",
      "side": 1,
      "message": "\u003e I would like to clarify that the current storage model, does not dictate this problem\n\nYes, we only ever use SHA1s of refs as cache keys in Gerrit today. We could use blob SHA1s (e.g. entries in NoteMaps) but these come at a much higher cost. Again, this depends on storage and ref backend but in most replicated settings the RefDb will be much cheaper to read and versatile throughout the request (other caches might just need ref SHA1s as well). At the minimum, one can assume that RefDb of All-Users is accessed so frequently that it itself is always in a git cache locally  if the setup has that or comes down from what ever global DB there is reasonably quickly (this is true for our setup and I am sure for others as well).\n\nI think you yourself raised this argument before: At least the ref-sha1 approach is tested terrain that we have a lot of experience with :-)\n\n\u003e If you go with the proposed consolidation of all the primary data to the user\u0027s ref, then you can avoid any slowdowns to the BatchUpdateRef having to update indexes because you will only have one ref.\n\nYes, but I am not sure I follow the rest of this proposal completely: If we move external IDs into refs/users/... and remove refs/meta/external-ids. How would I go from ExtId to Account(.Id) when the cache doesn\u0027t contain a record?\n\nWe could certainly cache:\nExternal.Id -\u003e (Account.Id, SHA1 of refs/users/...)\n\nWhich is fine for most cases, but what if we find that the record is outdated (e.g. the persistent cache has an issue in itself or the record is not yet replicated)?\n\nThe most prominent example is Gerrit in a master/slave setup with cache replication assuming a scenario where cache replication is a little behind. \n\nMy point is that there must be a reasonable way of computing the record that is not \"read and parse O(n) records\".\n\nI do agree that this would be simpler, wouldn\u0027t suffer from contention and through persisting the account cache would solve the cold start problem. But: We need to figure out how to get from ExtId or Email to an Account when the cache record isn\u0027t there. I am all ears if you have something in mind here.",
      "parentUuid": "c3dcdca8_3f2fa04a",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f80489bd_7791f4c7",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-11T18:10:50Z",
      "side": 1,
      "message": "I don\u0027t believe this is accurate. There are at least three factors affecting the limit here, the CPU processing limit, the git object db writing, and the git ref updates. We need to have a good understanding of how each of these are currently affecting updates in order to avoid the same issues with any new design. Can we get some numbers here?",
      "range": {
        "startLine": 55,
        "startChar": 55,
        "endLine": 55,
        "endChar": 111
      },
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "438ebf29_abbba480",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1085065
      },
      "writtenOn": "2019-07-11T19:06:22Z",
      "side": 1,
      "message": "If all users are insisting on the same ref that contains the data of all users, it is pretty clear that the whole system isn\u0027t scalable.\n\nAs the number of users grows, there is more contention and more data to write. I believe I gave you already some real numbers, can you make some tests on your side and provide alternative numbers?\n\nIf we put then the perspective of multi-master/multi-site, the contention is even more problematic because any user can update from a different site, causing the block of any other operation on refs/meta/external-ids until that change is propagated and up to date with the global ref-db.",
      "parentUuid": "f80489bd_7791f4c7",
      "range": {
        "startLine": 55,
        "startChar": 55,
        "endLine": 55,
        "endChar": 111
      },
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f9db1184_c54384e0",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 57,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-11T18:10:50Z",
      "side": 1,
      "message": "I don\u0027t believe this is an accurate picture. It should take milliseconds to update a loose ref on a normal (even NFS system), but it def could take seconds if updating packed-refs, and I suppose if using PAXOS on a global network. So both packed refs and loose refs are normal, but neither alone is \"usual\" since they could be order of magnitudes different.",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5dd53fad_cb264910",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 57,
      "author": {
        "id": 1085065
      },
      "writtenOn": "2019-07-11T19:06:22Z",
      "side": 1,
      "message": "It would never be milliseconds, because of the racy reads problem. Did you customize JGit to find another solution to the racy reads? If yes, it would be nice if you could contribute that to JGit mainstream, so that we can all have massive ref updates in msecs :-)",
      "parentUuid": "f9db1184_c54384e0",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bec6bbdb_a36f5552",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 59,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-11T18:10:50Z",
      "side": 1,
      "message": "It seems these numbers may not be accurate?\n\nHere too it is important to know what is taking 3s, Luca seems to believe it is a jgit ref update problem. If this is the case, then any proposed Gerrit improvement for lock contention will have to be designed to overcome this specific limitation. However, I am leary of trying to come up with any scheme that can do this if jgit is actually that broken. Mainly because if any new scheme appears to at least match this existing performance than we will not really know if it actually made things worse since it sounds like the current scheme does a 2.5s sleep? That would mean that any new scheme could potentially waste up to an extra 2.5s than the current scheme and we might not be able to measure the difference.",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "095ebdd0_9645c8f2",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 59,
      "author": {
        "id": 1085065
      },
      "writtenOn": "2019-07-11T19:06:22Z",
      "side": 1,
      "message": "\u003e It seems these numbers may not be accurate?\n\nPeak \u003d 83 updates/min, Average \u003d 3 secs. You can compare peak with average to see if numbers are accurate.\n\n\u003e Here too it is important to know what is taking 3s, Luca seems to believe it is a jgit ref update problem. If this is the case, then any proposed Gerrit improvement for lock contention will have to be designed to overcome this specific limitation.\n\nHaven\u0027t done instrumentation of those 3s yet, that\u0027s an average figure though. Peaks are much higher than that.\n\n\u003e However, I am leary of trying to come up with any scheme that can do this if jgit is actually that broken. Mainly because if any new scheme appears to at least match this existing performance than we will not really know if it actually made things worse since it sounds like the current scheme does a 2.5s sleep? That would mean that any new scheme could potentially waste up to an extra 2.5s than the current scheme and we might not be able to measure the difference.\n\nUnfortunately isn\u0027t 2.5s sleep, if you look at the JGit code is much worse than that: it\u0027s continuous read and reload of the packed refs, for 2.5s. However, that\u0027s a different problem and isn\u0027t related at all to the external ids.",
      "parentUuid": "bec6bbdb_a36f5552",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58fe0e9d_ab3e496d",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-11T18:10:50Z",
      "side": 1,
      "message": "Could you add an explanation as to why and how much you think this will improve over current lookups? It is not obvious how this will improve things. I am guessing that the intent is for the fixed size sharding (i.e reading shard_ratio fewer accounts) what you think will improve the performance? Is that what you think will make it \"fast\", or is there something else?\n\nI understand that you can\u0027t have real numbers without code, but I having a formulaic improvement would be useful. My guess is that given an email, it will take on git ref lookup, and git data lookup which reads one entire shard worth of accounts, N/shard_ratio, to get one accountId. It will then require follow-on lookups to get any extra account data. Is this what you are expecting? \n\nCould you similarly qualify what the current lookup approach so as to get a picture of whether this will be faster or slower, and in what conditions? There is mention about data sizes making things slow, and this usually the case with CPU bound stuff, but if we are going to primary storage, then latency can often be the limiting factor, not necessarily how much data you are fetching (this is particularly true for the google team I suspect). I want to make sure that roundtrips to storage are quantified in both scenarios.",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "584637d2_a26e9737",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-11T21:18:28Z",
      "side": 1,
      "message": "If my understanding is right, given the current primary storage (not the current lookup code) approach of refs/meta/external-ids, I believe it requires at a minimum one \"full git round trip\" (see *1 below) to go from an external id to a password, and this new index will require at a minimum two \"full git round trips\"?  The current data as documented here: https://gerrit-review.googlesource.com/Documentation/config-accounts.html#external-ids might look like this:\n\n [externalId \"username:jdoe\"]\n   accountId \u003d 1003407\n   email \u003d jdoe@example.com\n   password \u003d bcrypt:4:LCbmSBDivK/hhGVQMfkDpA\u003d\u003d:XcWn0pKYSVU/UJgOvhidkEtmqCp6oKB7\n\nSo to get the password for externalId \"username:jdoe\", I would hash \"username:jdoe\" and get the file for it. I don\u0027t believe there is a technical reason I would have to read any more data (all the other externalId files) from refs/meta/external-ids to get that one file. That lookup requires at a minimum the \"full git round trip\" retrieving and the 4 lines of data above to be retrieved and some \"other git data\" (see *2 below), but not a lot of data.\n\nIn the proposed index layout, I believe it would require at a minimum 2 \"full round trip\"s to primary storage and approximately the same amount of data to be retrieved as using the current storage model. The first full round trip\" fetch would also hash \"username:jdoe\" and get the accountId for it. I think the second \"full round trip\" fetch would then get the password from the new external-ids.config file on refs/users/uu/vvvvvuu?\n\nWhat I am understanding is that currently to go from email to accountId (not a full use case since you then probably want to do something with that accountId), I would have to read on average half the files on refs/meta/external-ids to find the accountId. This is a lot of data (.5 X number_of_accounts blobs), but it is actually only one git ref/objects roundtrip, so it can be fast in some situations, but slow in others. I think this is the piece you would really like to improve? One advantage of this, is that some of the data you might want might already be in the blobs you loaded. One quick idea worth thinking about to speed this up, would be to improve the current design by adding additional entries, keyed by the email, to refs/meta/external-ids, that point to the same blob that currently contains the external-id. Using this approach would keep the advantages of the current storage model, fast lookups from externalId, and it would add fast lookups from email, all while avoid having an extra ref that can get out of sync.\n\n\n*1 By a \"full git round trip\", I mean likely 5 smaller roundtrips.\n 1) get commit sha1 from ref\n 2) get commit from sha1 (parse tree sha1)\n 3) get tree from tree sha1 (parse 2 char subtree sha1)\n 4) get subtree from subtree sha1 (parse blob sha1)\n 5) get blob from blob sha1\n\n*2 By \"other git data\" for 50K accounts I mean:\n 1) the sha1 of the commit\n 2) the commit data\n 3) the first treeish ~256 * ~42 bytes\n 4) the second treeish ~195 * ~82 bytes",
      "parentUuid": "58fe0e9d_ab3e496d",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13ceed63_9250cc23",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-12T12:44:16Z",
      "side": 1,
      "message": "\u003e Could you add an explanation as to why and how much you think this will improve over current lookups? It is not obvious how this will improve things. I am guessing that the intent is for the fixed size sharding (i.e reading shard_ratio fewer accounts) what you think will improve the performance? Is that what you think will make it \"fast\", or is there something else?\n\nThe fixed size sharding (the \u003cshard\u003e part of refs/index/account-by-external-id/\u003cshard\u003e) will only ever help with write contention, it\u0027s not meant for read performance. I see that this leads to confusion in the discussion, so let\u0027s leave that ref sharding aside for now and look at what else there is. If this sharding is useful or not is a discussion that can easier be done separately just focusing on that.\n\nSo, minus sharding, the proposal is:\n\nOld system:\n- ExtId data in refs/meta/external-ids\n- Account-by-External-ID lookup by using refs/meta/external-ids or ExternalIDCache\n- Account-by-Email lookup by using ExternalIDCache\n- External-ID-by-Account-ID lookup only through ExternalIDCache\n\nCaches:\n- AccountCache (not persisted, empty on restarts, complex eviction propagation, no state sharding, etc.)\n- External ID cache (long reload time, has to reload ALL data whenever a single extID changes)\n\nProposed system:\n- ExtId data in refs/users/...\n- Account-by-External-ID lookup by using refs/index/external-ids\n- Account-by-Email lookup by using refs/index/external-ids\n- External-ID-by-Account-ID lookup using AccountState (hence refs/users/...)\n\nCaches:\n- AccountCache (immutable, serialized: through serialization not empty on startup, no eviction propagation, etc.). All enabled by having all data for AccountState live in refs/users/... and change only if the account changes\n- (optional) Account-by-External-ID-Cache (immutable, serialized, only changes when data for that account changes)\n- (optional) Account-by-Email-Cache (immutable, serialized, only changes when data for that account changes)\n- No need for ExternalIDCache\n\nI see you are asking a lot about the index refs. In the end we are presented with a problem of linking two types of entities - Account and ExternalID - for fast lookups from either one to the other. Currently, that is implemented by offering one way in the primary storage (ExtID-\u003eAccount) and the other way (Account-\u003eExtId) through a cache (ExternalIDCache) that suffers from loading gaps for aforementioned reasons.\n\nSo to your question: Can we add emails to refs/meta/external-ids? Yes, but it solves only part of the issue. We would need to create a backlink in refs/users/... for each account to point to a list of external IDs to solve the remaining issue. This is pretty much what the current design proposal is, just turned upside down (ExternalID data in refs/meta/external-ids instead of refs/users/...). Between the two, I favor the current proposal because it makes it more clear that one is just a loop stricture (refs/index/...) and having all data for AccountState in refs/users/... feels a bit more natural for the AccountCache being keyed by that SHA1.\n\nTo your point about lookup cost: All lookups but one improve or have the same performance as they do right now, so let\u0027s look at the one that in theory does not: Logging in users (ExtID-\u003eAccount).\n\nCurrent:\n1) Load ref map of All-Users\n2) Load note from refs/meta/external-ids\n3) Done.\n\nThen (cold cache):\n1) Load ref map of All-Users\n2) Load note from refs/index/external-ids\n3) Load file from refs/users/...\n\nThen (cache):\n1) Load ref map of All-Users\n2) (cache) AccountByExternalID\n3) (cache) AccountById\n\nBoth of these caches will have a very high hit rate. A miss only occurs if a user updates their account. So even in that case we could get a better performance by just having to load the ref map (which we need for a variety of other things in the same request usually).",
      "parentUuid": "584637d2_a26e9737",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ddc3a38_e397e4d9",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-12T19:31:32Z",
      "side": 1,
      "message": "Thank you for some good explanation as to the intent,expectations, and reasoning of your proposal. I hope much of this can make it into the doc.",
      "parentUuid": "13ceed63_9250cc23",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b35fab9a_065dd57f",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 129,
      "author": {
        "id": 1026112
      },
      "writtenOn": "2019-07-15T14:53:04Z",
      "side": 1,
      "message": "Absolutely. I want to wait until all discussion is settled so that I can go over the doc once more to fill in results of or summaries of what was discussed.",
      "parentUuid": "9ddc3a38_e397e4d9",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "19a4fa3e_04a890a8",
        "filename": "pages/design-docs/external-id-storage-revamp/doc.md",
        "patchSetId": 5
      },
      "lineNbr": 137,
      "author": {
        "id": 1003883
      },
      "writtenOn": "2019-07-11T18:10:50Z",
      "side": 1,
      "message": "Without an example of how this is different from the `refs/meta/external-ids`, it is hard to picture how this will lead to a performance improvement.",
      "revId": "bc3fbf26a3899658fdb2c6ec7b8c9f51934a74a6",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}