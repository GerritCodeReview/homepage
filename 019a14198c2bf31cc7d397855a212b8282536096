{
  "comments": [
    {
      "key": {
        "uuid": "3e7b4b5f_61c1bbea",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-23T12:28:22Z",
      "side": 1,
      "message": "This would indeed be a very desirable feature for Gerrit. Thanks for proposing this and working on a solution for it.",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 24,
        "endChar": 37
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c6784621_ab47798f",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-08-05T13:11:50Z",
      "side": 1,
      "message": "this is quite vague; can you give specific examples of incidents, and how GPG signing of commits would have prevented them?\n\nAre you doing this on behalf of a client that is looking to increase their security, or is this part of an academic research project?",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 36
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b9089906_227e031f",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-08-05T16:15:51Z",
      "side": 1,
      "message": "\u003e This would indeed be a very desirable feature for Gerrit. Thanks for proposing this and working on a solution for it.\n\nThanks for considering this proposal.",
      "parentUuid": "3e7b4b5f_61c1bbea",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 24,
        "endChar": 37
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1580fc23_ef54dfba",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-23T12:28:22Z",
      "side": 1,
      "message": "What would it take to implement the feature in Gerrit? What would the design/implementation look like?\n\nSince Gerrit already supports GPG-signed pushs, having GPG-signed commits in the browser would be a nice addition. If there are some aspects of GPG-signed commits which can\u0027t be implemented directly in Gerrit, it would be interesting to hear about them, too.\n\nThe reason I\u0027m asking is that we (ESC) would like to understand the whole picture and evaluate whether the tree API in combination with the browser extension is the best solution from a Gerrit (and Gerrit user) perspective.",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 27,
        "endChar": 28
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71d3031e_fa0d6c70",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-07-24T14:56:12Z",
      "side": 1,
      "message": "The design and implementation would be similar to our prior work, the “le-git-imate” commit signing extension, which we designed and implemented for GitHub and GiLab. I will provide a summary description of le-git-imate (including the role of the tree API in the browser extension) in response to the next comment.\n\nI should mention that it is not possible to implement user commit signing directly on the server side (e.g. on Gerrit). Indeed, the server cannot cryptographically sign the commits on behalf of users without requiring users to share their private keys with the server.\n\nNote that we are actively working on implementing the commit/review signing feature in Gerrit. For an efficient implementation and a minimal impact on users experience, we need the tree API to be part of core Gerrit. In addition to our prior work for GitHub/GitLab, signing commits/reviews in Gerrit would require additional security analysis, since the process is more complex than signing commits in GitHub/GitLab.",
      "parentUuid": "1580fc23_ef54dfba",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 27,
        "endChar": 28
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "550c7192_bf176141",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "\u003e The design and implementation would be similar to our prior work, the “le-git-imate” commit signing extension, which we designed and implemented for GitHub and GiLab. I will provide a summary description of le-git-imate (including the role of the tree API in the browser extension) in response to the next comment.\n\u003e \n\u003e I should mention that it is not possible to implement user commit signing directly on the server side (e.g. on Gerrit). Indeed, the server cannot cryptographically sign the commits on behalf of users without requiring users to share their private keys with the server.\n\u003e\n\nI see. Would it be possible to do the signing part in the frontend of Gerrit? (I guess it would be similar to what le-git-imate already does, just that it\u0027s directly in Gerrit.)\n\nOf course, the tree API would be necessary as a backend element.\n\n\u003e \n\u003e Note that we are actively working on implementing the commit/review signing feature in Gerrit. For an efficient implementation and a minimal impact on users experience, we need the tree API to be part of core Gerrit. In addition to our prior work for GitHub/GitLab, signing commits/reviews in Gerrit would require additional security analysis, since the process is more complex than signing commits in GitHub/GitLab.\n\nThat\u0027s great to hear. Out of curiosity, why is the process in Gerrit more complex? Is it because of some of the examples I mentioned in my other comment? Does the Change-Id in the commit message cause issues?",
      "parentUuid": "71d3031e_fa0d6c70",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 27,
        "endChar": 28
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6ed708d_295305f8",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-08-05T16:15:51Z",
      "side": 1,
      "message": "\u003e \u003e The design and implementation would be similar to our prior work, the “le-git-imate” commit signing extension, which we designed and implemented for GitHub and GiLab. I will provide a summary description of le-git-imate (including the role of the tree API in the browser extension) in response to the next comment.\n\u003e \u003e \n\u003e \u003e I should mention that it is not possible to implement user commit signing directly on the server side (e.g. on Gerrit). Indeed, the server cannot cryptographically sign the commits on behalf of users without requiring users to share their private keys with the server.\n\u003e \u003e\n\u003e \n\u003e I see. Would it be possible to do the signing part in the frontend of Gerrit? (I guess it would be similar to what le-git-imate already does, just that it\u0027s directly in Gerrit.)\n\nCan you please elaborate this question? I am not sure if I understand it correctly. The design has to be carefully considered in order to be aligned with the threat model for user commit/review signatures, in which the server may be untrusted.\n\n\u003e \n\u003e Of course, the tree API would be necessary as a backend element.\n\u003e \n\u003e \u003e \n\u003e \u003e Note that we are actively working on implementing the commit/review signing feature in Gerrit. For an efficient implementation and a minimal impact on users experience, we need the tree API to be part of core Gerrit. In addition to our prior work for GitHub/GitLab, signing commits/reviews in Gerrit would require additional security analysis, since the process is more complex than signing commits in GitHub/GitLab.\n\u003e \n\u003e That\u0027s great to hear. Out of curiosity, why is the process in Gerrit more complex? Is it because of some of the examples I mentioned in my other comment? Does the Change-Id in the commit message cause issues?\n\nAs you gave some examples in other comments, on Gerrit we have to deal with new challenges like merge policies, reviews, etc. I should draft another document to explain the issues that we already encountered.\nThough the commit signing on Gerrit is kinda similar to what we did on GitHub/GitLab, there are new challenges from a technical point of view. For example, the merge commit is not only about sending new Git objects to the server.\nIn case of the review signing, we have security/usability concerns and our design and threat model are not finalized yet.",
      "parentUuid": "550c7192_bf176141",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 27,
        "endChar": 28
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a5150e3_a8b13360",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-23T12:28:22Z",
      "side": 1,
      "message": "Can you please go into details how this works? It would be helpful to understand the whole process: when/how the signing is triggered; which elements (e.g. tree of commit) are combined in which way to generate the signature; what the signature entails, and how this signature is then reported back and presented to the user.\n\nI guess the document you linked contains some of these details. It\u0027s a bit long, though, and contains also many other aspects. Can you please outline the process in an easy-to-understand summary?",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d103e50_9187b6bf",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-07-24T14:56:12Z",
      "side": 1,
      "message": "We designed and implemented the le-git-imate browser extension to achieve user commit signing in web-based Git hosting repositories like GitHub/GitLab. \n\nle-git-imate creates a true GPG-signed Git commit object in the browser which means the signature is computed over commit fields and is part of the commit done through the web UI. As a result, the signature provides the exact same security guarantees offered by Git\u0027s standard commit signing.\n\nIndeed, the commit signature allows tools like Git client to cryptographically verify that the actions executed by the GitHub/GitLab server on behalf of the user are performed correctly. That said, anyone (including the committer/author of the commit) who clones the repository can validate the commit signature.\n\nFrom the user\u0027s perspective, le-git-imate’s works as follows:\nAfter preparing the commit, instead of using GitHub’s “commit/merge” button to commit the change, the user hits the extension button. Then the following steps take place:\nStep 1: The extension computes the new commit and displays a popup window with three text areas: (1) information about the parent commit, (2) changes between the new commit and the parent commit, (3) the new commit.\nStep 2: If the user is satisfied with the new commit, she hits a button called “finalize commit” by which the new signed Git commit is pushed to the server. \n\nFrom a technical point of view, le-git-imate performs the following steps in the background:\n1) Collect information about the commit form webUI\n2) Compute the “tree hash” of the new commit using an optimized algorithm\n3) Compute a true GPG-signed Git commit\n4) Create all new blob and tree objects related to the new commit\n5) Create a packfile of all the objects (i.e, commit, blob, tree)\n6) Push the packfile to the server using git pack protocol\n\nA few points about above steps:\nWe rely on GitHub/GitLab APIs to retrieve the minimum number of Git blob/tree objects from the server to compute the tree hash.\nWe use an optimized algorithm since unlike the normal Git, it does not need the entire repository to compute the new commit. Instead, it uses GitHub/GitLab APIs to retrieve only a minimum set of Git objects to compute the new tree hash and therefore the new commit object.\nTo create a signed commit object in the browser and push it to the server, we re-implement the functionality of the git-commit (for both regular and merge commits) and git-send-pack commands in the browser (in JavaScript).\n\nle-git-imate is described in more detail in the academic publication linked in the design document. Note that, after this publication, we were able to further the development of the extension to generate true GPG-signed Git commit objects.",
      "parentUuid": "3a5150e3_a8b13360",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17cb370e_a672a843",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "Thank you for all those details. I now see much better how the tree API fits into the process.\n\nThe following questions are unrelated to the tree API. I just would like to understand the full picture for le-git-imate in combination with Gerrit. I hope you don\u0027t mind this.\n\nDo I understand correctly (for GitHub/GitLab) that the signing should be used when\n1) a user creates a new commit directly on the web UI?\n2) a user merges a pull request?\n\nIn case (1), is it also possible to edit the commit again and post another version of it?\n\nDoes le-git-imate automatically guess from the context which action (of the two above) a user wants to do or does it have a dedicated button/action for each of them?\n\nRegarding Gerrit, I\u0027m wondering if it will be that easy to replace the standard UI actions with corresponding ones in le-git-imate. For instance, Gerrit has different submit/merge types (e.g. MergeIfNecessay, RebaseIfNecessary) which can be configured per repository. Would le-git-imate respect them as well?\n\nWill submit/merging be implemented by uploading a new commit to Gerrit and then relying on Gerrit\u0027s auto-close feature for changes? What if the user lacks permission to directly push to the master branch of the repository (as is common for many Gerrit installations to protect the master branch from unreviewed commits)?\n\nWhen it comes to editing, I guess you would need to replace Gerrit\u0027s \"Publish Edit\", wouldn\u0027t you? Since the commit is created fully on the frontend, the new commit would need to be uploaded as a new patch set and the existing edit would need to be discarded/deleted. Or did you find a smarter way?\n\nWould signing be also available for other actions on Gerrit\u0027s change screen like \"Rebase\", \"Cherry-pick\", \"Create follow-up change\", or \"Revert\"?",
      "parentUuid": "6d103e50_9187b6bf",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7029887b_5aa325fb",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-08-05T13:22:13Z",
      "side": 1,
      "message": "\u003e Indeed, the commit signature allows tools like Git client to cryptographically verify that the \u003e actions executed by the GitHub/GitLab server on behalf of the user are performed correctly. \n\nHow realistic is this concern, though? I\u0027m asking because we at Google are very much worried that clients got themselves hacked (since not all clients are managed tightly), and are pushing rogue code.  \n\nIf however, an adversary is already in the position to control what goes on inside the Git/Gerrit server, then we\u0027re already in a very bad place.",
      "parentUuid": "17cb370e_a672a843",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17dfd123_035a5224",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-08-05T16:15:51Z",
      "side": 1,
      "message": "\u003e Do I understand correctly (for GitHub/GitLab) that the signing should be used when\n\u003e 1) a user creates a new commit directly on the web UI?\n\u003e 2) a user merges a pull request?\n\nYes.\n\n\u003e In case (1), is it also possible to edit the commit again and post another version of it?\n\nYes. You can consider le-git-imate as a git client tool which means you can make changes to the repository and then create a new commit/revision  repository (create a new signed commit that reflects new changes).\n\n\u003e Regarding Gerrit, I\u0027m wondering if it will be that easy to replace the standard UI actions with corresponding ones in le-git-imate. For instance, Gerrit has different submit/merge types (e.g. MergeIfNecessay, RebaseIfNecessary) which can be configured per repository. Would le-git-imate respect them as well?\n\nIn our prototype implementation, we already considered the \"always merge” policy. But it wouldn\u0027t be a major problem to support other options. \nWe are working on how to integrate all Gerrit policies into our extension. For instance, different policies can be defined in the le-git-imate setup step.\n\n\u003e Will submit/merging be implemented by uploading a new commit to Gerrit and then relying on Gerrit\u0027s auto-close feature for changes? \n\nCurrently we rely on Gerrit auto-close though we can use Gerrit APIs to close the change. We would be happy to discuss it further for the alternative approaches. \n\n\u003e What if the user lacks permission to directly push to the master branch of the repository (as is common for many Gerrit installations to protect the master branch from unreviewed commits)?\n\nThere are such permission issues on GiHub/GitLab as well. In those cases, we warn the user (a pop-up message) about the issue. This is another example of issues that we can discuss more.\n\n\u003e When it comes to editing, I guess you would need to replace Gerrit\u0027s \"Publish Edit\", wouldn\u0027t you? Since the commit is created fully on the frontend, the new commit would need to be uploaded as a new patch set and the existing edit would need to be discarded/deleted. Or did you find a smarter way?\n\nYes, we do publish the edit. From a security point of view, we would like to keep track of everything in the repository history (discard nothing). However, our design is not finalized yet and we would be happy to get advice from your side. \n\n\u003e Would signing be also available for other actions on Gerrit\u0027s change screen like \"Rebase\", \"Cherry-pick\", \"Create follow-up change\", or \"Revert\"?\n\nAt the moment, we are not working on them since we are focus on the core implementation. In general, supporting those actions is a matter of re-implementing some git functionalities (e.g., git rebase) in the browser. They can definitely be considered as a future plan.",
      "parentUuid": "7029887b_5aa325fb",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c779515c_46d13b11",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "Would le-git-imate also work with only this option?",
      "range": {
        "startLine": 53,
        "startChar": 45,
        "endLine": 53,
        "endChar": 53
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caf45f58_721dd041",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "If the tree is very large, it could take quite some time to walk through all of it. Have you tried the proposed implementation on large trees? If so, with which results?",
      "range": {
        "startLine": 53,
        "startChar": 34,
        "endLine": 53,
        "endChar": 43
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ec7dcb8b_ad3a6b50",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-08-05T16:15:51Z",
      "side": 1,
      "message": "\u003e Would le-git-imate also work with only this option?\n\nle-git-imate works with both path and treeId options.\nActually, on Github it works with treeIds, and on GitLab it uses the path option. Note, GitHub does not support tree retrieval by path.",
      "parentUuid": "c779515c_46d13b11",
      "range": {
        "startLine": 53,
        "startChar": 45,
        "endLine": 53,
        "endChar": 53
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0e360f97_75973e89",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-08-05T16:15:51Z",
      "side": 1,
      "message": "\u003e If the tree is very large, it could take quite some time to walk through all of it. Have you tried the proposed implementation on large trees? If so, with which results?\n\nYou are right. Using the recursive option, there might be a performance or timeout issue to load a large tree with thousands of files. In such cases, the API should truncate tree to a max, let\u0027s say, 1000. That’s what GitHub/GitLab does. If the items in the tree array exceeded the limit, the user would be notified to iterate the request for more items. \n\nWe have not proposed this truncate option in the Gerrit Tree API, but we can do it.\n\nSpeaking of the le-git-imate performance on large repos, though we did not benchmark the extension with \"a very large repository\", we did benchmark with a variety of repositories with different history sizes, file counts, directory-tree depths and file sizes (such as atom and react). And we did not face the truncate issue.\nThat is mainly because of two reasons:\n1) The le-git-imate\u0027s performance does not depend on the size of a repository. Instead it depends only on the number of files/directories that are changed in a commit. \n\n2) le-git-imate does not use the recursive option to fetch all trees. Instead it retrieves the minimum number of Git objects that are necessary to create the new commit.\n\nWe evaluated over 50K merge requests on top 50 most starred GitHub projects (as of Feb. 2018). Our statistics show that the median number of commits and changed files in the PR branch are 4 and 3, respectively. In other words, the number of changed files in the vast majority of merge requests is small. Thus there is little chance that the number of retrieved tree entries that are involved in a commit exceeds the GitHub/GitLab limit (1000). That said, le-git-imate usually fetches few tree objects and does not deal with the truncate issue (even in a large repository). You may check out the evaluation section in the paper for more details.",
      "parentUuid": "caf45f58_721dd041",
      "range": {
        "startLine": 53,
        "startChar": 34,
        "endLine": 53,
        "endChar": 43
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2f21d94_7db382c4",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 55,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "It would be good to define the returned data objects and their hierarchy.\n\nWhat I saw in the implementation so far for a tree entry:\n- SHA-1\n- Mode\n- Path\n- Type\n\nIs the \u0027path\u0027 the full path or just the \u0027name\u0027 within the directory?\n\nIs the \u0027mode\u0027 something you would need for le-git-imate?",
      "range": {
        "startLine": 55,
        "startChar": 35,
        "endLine": 55,
        "endChar": 51
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40e98ebc_1b37874e",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 55,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-08-05T16:15:51Z",
      "side": 1,
      "message": "\u003e It would be good to define the returned data objects and their hierarchy.\n\nI will update the document to address your concern. Meanwhile, the hierarchy is quite similar to the output of git cat-file -p \u003ctreeId\u003e.\n\n\u003e What I saw in the implementation so far for a tree entry:\n\u003e - SHA-1\n\u003e - Mode\n\u003e - Path\n\u003e - Type\n\u003e \n\u003e Is the \u0027path\u0027 the full path or just the \u0027name\u0027 within the directory?\n\nJust \u0027name\u0027 within the directory.\n\n\u003e Is the \u0027mode\u0027 something you would need for le-git-imate?\n\nYes, we need it for le-git-imate. A tree object is computed over tree entries, each entry is defined by four fields: SHA-1, Mode, Path, Type.",
      "parentUuid": "c2f21d94_7db382c4",
      "range": {
        "startLine": 55,
        "startChar": 35,
        "endLine": 55,
        "endChar": 51
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7dd18943_fb051fef",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "Do you have a use case in mind for which this would be helpful?",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 38
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c938a01c_6fa3f4f1",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-08-05T16:15:51Z",
      "side": 1,
      "message": "\u003e Do you have a use case in mind for which this would be helpful?\n\nAs I mentioned earlier, le-git-imate works with both path and treeId options. In general, the path option is preferable to make less API requests, and therefore to improve the le-git-imate performance. So, we don\u0027t need that option for le-git-imate (at least at the moment). However, depending on the number of change files and the directory depth in the repository, we \"may\" be able to improve the le-git-imate performance by using both path and treeId.\n\nOther than that, I have no use case on top of my mind. People in other projects (who already requested a tree-API feature on Gerrit) might need the treeId option as well.",
      "parentUuid": "7dd18943_fb051fef",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 38
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1efbb63_d40e1089",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2019-07-19T20:06:32Z",
      "side": 1,
      "message": "Is this true even when using Git protocol\u0027s \u0027filter\u0027 feature (crbug.com/git/2)?",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 72,
        "endChar": 26
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7aa8c6b7_8e513f85",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-07-20T18:23:44Z",
      "side": 1,
      "message": "Yes, if we exclude filter options that need the server-side support (e.g, configs for the shallow clone),",
      "parentUuid": "f1efbb63_d40e1089",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 72,
        "endChar": 26
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9f5fff9_2300af62",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2019-08-02T19:58:27Z",
      "side": 1,
      "message": "filter\u003dblob:none doesn\u0027t require any server-side setup. Likewise filter\u003dtree:0.",
      "parentUuid": "7aa8c6b7_8e513f85",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 72,
        "endChar": 26
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a47e3315_a3cd1b6c",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-08-05T16:23:21Z",
      "side": 1,
      "message": "\u003e filter\u003dblob:none doesn\u0027t require any server-side setup. Likewise filter\u003dtree:0.\n\nPlease correct me, if I am wrong.\nYou are saying that `filter\u003dblob:none` or `filter\u003dtree:0` options would not be ignored by the server even if the following configs are not set on the server side?\nuploadpack.allowfilter\nuploadpack.allowanysha1inwant\n\nIf so, please confirm that doing the following git command, blobs are not downloaded?\ngit clone --filter\u003dblob:none https://github.com/in-toto/in-toto\n\nAnd you do not get this message? \n\"warning: filtering not recognized by server, ignoring\"\n\nIf so, then what is this about?\nhttps://github.com/git/git/blob/master/fetch-pack.c#L964-#L969\n\nAnd what is the purpose of following git test scripts?\nhttps://github.com/git/git/blob/master/t/t5702-protocol-v2.sh#L309-#L319\nhttps://github.com/git/git/blob/master/t/t5702-protocol-v2.sh#L383-#L409\n\nSorry for asking so many questions!",
      "parentUuid": "d9f5fff9_2300af62",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 72,
        "endChar": 26
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0a0e378b_138c01cc",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 83,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2019-07-19T20:06:32Z",
      "side": 1,
      "message": "Hm, what complex functionality are you referring to?",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 83,
        "endChar": 21
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aaa3c077_96ee94d1",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 83,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-07-20T18:23:44Z",
      "side": 1,
      "message": "Well, I would rephrase the statement as follows:\nit may be overkill to have to install a plugin\nwhile you need only a tiny portion of it (one simple API).",
      "parentUuid": "0a0e378b_138c01cc",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 83,
        "endChar": 21
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}