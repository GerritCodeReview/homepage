{
  "comments": [
    {
      "key": {
        "uuid": "3e7b4b5f_61c1bbea",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-23T12:28:22Z",
      "side": 1,
      "message": "This would indeed be a very desirable feature for Gerrit. Thanks for proposing this and working on a solution for it.",
      "range": {
        "startLine": 21,
        "startChar": 0,
        "endLine": 24,
        "endChar": 37
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c6784621_ab47798f",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-08-05T13:11:50Z",
      "side": 1,
      "message": "this is quite vague; can you give specific examples of incidents, and how GPG signing of commits would have prevented them?\n\nAre you doing this on behalf of a client that is looking to increase their security, or is this part of an academic research project?",
      "range": {
        "startLine": 23,
        "startChar": 0,
        "endLine": 24,
        "endChar": 36
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1580fc23_ef54dfba",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-23T12:28:22Z",
      "side": 1,
      "message": "What would it take to implement the feature in Gerrit? What would the design/implementation look like?\n\nSince Gerrit already supports GPG-signed pushs, having GPG-signed commits in the browser would be a nice addition. If there are some aspects of GPG-signed commits which can\u0027t be implemented directly in Gerrit, it would be interesting to hear about them, too.\n\nThe reason I\u0027m asking is that we (ESC) would like to understand the whole picture and evaluate whether the tree API in combination with the browser extension is the best solution from a Gerrit (and Gerrit user) perspective.",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 27,
        "endChar": 28
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71d3031e_fa0d6c70",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-07-24T14:56:12Z",
      "side": 1,
      "message": "The design and implementation would be similar to our prior work, the “le-git-imate” commit signing extension, which we designed and implemented for GitHub and GiLab. I will provide a summary description of le-git-imate (including the role of the tree API in the browser extension) in response to the next comment.\n\nI should mention that it is not possible to implement user commit signing directly on the server side (e.g. on Gerrit). Indeed, the server cannot cryptographically sign the commits on behalf of users without requiring users to share their private keys with the server.\n\nNote that we are actively working on implementing the commit/review signing feature in Gerrit. For an efficient implementation and a minimal impact on users experience, we need the tree API to be part of core Gerrit. In addition to our prior work for GitHub/GitLab, signing commits/reviews in Gerrit would require additional security analysis, since the process is more complex than signing commits in GitHub/GitLab.",
      "parentUuid": "1580fc23_ef54dfba",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 27,
        "endChar": 28
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "550c7192_bf176141",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "\u003e The design and implementation would be similar to our prior work, the “le-git-imate” commit signing extension, which we designed and implemented for GitHub and GiLab. I will provide a summary description of le-git-imate (including the role of the tree API in the browser extension) in response to the next comment.\n\u003e \n\u003e I should mention that it is not possible to implement user commit signing directly on the server side (e.g. on Gerrit). Indeed, the server cannot cryptographically sign the commits on behalf of users without requiring users to share their private keys with the server.\n\u003e\n\nI see. Would it be possible to do the signing part in the frontend of Gerrit? (I guess it would be similar to what le-git-imate already does, just that it\u0027s directly in Gerrit.)\n\nOf course, the tree API would be necessary as a backend element.\n\n\u003e \n\u003e Note that we are actively working on implementing the commit/review signing feature in Gerrit. For an efficient implementation and a minimal impact on users experience, we need the tree API to be part of core Gerrit. In addition to our prior work for GitHub/GitLab, signing commits/reviews in Gerrit would require additional security analysis, since the process is more complex than signing commits in GitHub/GitLab.\n\nThat\u0027s great to hear. Out of curiosity, why is the process in Gerrit more complex? Is it because of some of the examples I mentioned in my other comment? Does the Change-Id in the commit message cause issues?",
      "parentUuid": "71d3031e_fa0d6c70",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 27,
        "endChar": 28
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a5150e3_a8b13360",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-07-23T12:28:22Z",
      "side": 1,
      "message": "Can you please go into details how this works? It would be helpful to understand the whole process: when/how the signing is triggered; which elements (e.g. tree of commit) are combined in which way to generate the signature; what the signature entails, and how this signature is then reported back and presented to the user.\n\nI guess the document you linked contains some of these details. It\u0027s a bit long, though, and contains also many other aspects. Can you please outline the process in an easy-to-understand summary?",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d103e50_9187b6bf",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-07-24T14:56:12Z",
      "side": 1,
      "message": "We designed and implemented the le-git-imate browser extension to achieve user commit signing in web-based Git hosting repositories like GitHub/GitLab. \n\nle-git-imate creates a true GPG-signed Git commit object in the browser which means the signature is computed over commit fields and is part of the commit done through the web UI. As a result, the signature provides the exact same security guarantees offered by Git\u0027s standard commit signing.\n\nIndeed, the commit signature allows tools like Git client to cryptographically verify that the actions executed by the GitHub/GitLab server on behalf of the user are performed correctly. That said, anyone (including the committer/author of the commit) who clones the repository can validate the commit signature.\n\nFrom the user\u0027s perspective, le-git-imate’s works as follows:\nAfter preparing the commit, instead of using GitHub’s “commit/merge” button to commit the change, the user hits the extension button. Then the following steps take place:\nStep 1: The extension computes the new commit and displays a popup window with three text areas: (1) information about the parent commit, (2) changes between the new commit and the parent commit, (3) the new commit.\nStep 2: If the user is satisfied with the new commit, she hits a button called “finalize commit” by which the new signed Git commit is pushed to the server. \n\nFrom a technical point of view, le-git-imate performs the following steps in the background:\n1) Collect information about the commit form webUI\n2) Compute the “tree hash” of the new commit using an optimized algorithm\n3) Compute a true GPG-signed Git commit\n4) Create all new blob and tree objects related to the new commit\n5) Create a packfile of all the objects (i.e, commit, blob, tree)\n6) Push the packfile to the server using git pack protocol\n\nA few points about above steps:\nWe rely on GitHub/GitLab APIs to retrieve the minimum number of Git blob/tree objects from the server to compute the tree hash.\nWe use an optimized algorithm since unlike the normal Git, it does not need the entire repository to compute the new commit. Instead, it uses GitHub/GitLab APIs to retrieve only a minimum set of Git objects to compute the new tree hash and therefore the new commit object.\nTo create a signed commit object in the browser and push it to the server, we re-implement the functionality of the git-commit (for both regular and merge commits) and git-send-pack commands in the browser (in JavaScript).\n\nle-git-imate is described in more detail in the academic publication linked in the design document. Note that, after this publication, we were able to further the development of the extension to generate true GPG-signed Git commit objects.",
      "parentUuid": "3a5150e3_a8b13360",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "17cb370e_a672a843",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "Thank you for all those details. I now see much better how the tree API fits into the process.\n\nThe following questions are unrelated to the tree API. I just would like to understand the full picture for le-git-imate in combination with Gerrit. I hope you don\u0027t mind this.\n\nDo I understand correctly (for GitHub/GitLab) that the signing should be used when\n1) a user creates a new commit directly on the web UI?\n2) a user merges a pull request?\n\nIn case (1), is it also possible to edit the commit again and post another version of it?\n\nDoes le-git-imate automatically guess from the context which action (of the two above) a user wants to do or does it have a dedicated button/action for each of them?\n\nRegarding Gerrit, I\u0027m wondering if it will be that easy to replace the standard UI actions with corresponding ones in le-git-imate. For instance, Gerrit has different submit/merge types (e.g. MergeIfNecessay, RebaseIfNecessary) which can be configured per repository. Would le-git-imate respect them as well?\n\nWill submit/merging be implemented by uploading a new commit to Gerrit and then relying on Gerrit\u0027s auto-close feature for changes? What if the user lacks permission to directly push to the master branch of the repository (as is common for many Gerrit installations to protect the master branch from unreviewed commits)?\n\nWhen it comes to editing, I guess you would need to replace Gerrit\u0027s \"Publish Edit\", wouldn\u0027t you? Since the commit is created fully on the frontend, the new commit would need to be uploaded as a new patch set and the existing edit would need to be discarded/deleted. Or did you find a smarter way?\n\nWould signing be also available for other actions on Gerrit\u0027s change screen like \"Rebase\", \"Cherry-pick\", \"Create follow-up change\", or \"Revert\"?",
      "parentUuid": "6d103e50_9187b6bf",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7029887b_5aa325fb",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1024147
      },
      "writtenOn": "2019-08-05T13:22:13Z",
      "side": 1,
      "message": "\u003e Indeed, the commit signature allows tools like Git client to cryptographically verify that the \u003e actions executed by the GitHub/GitLab server on behalf of the user are performed correctly. \n\nHow realistic is this concern, though? I\u0027m asking because we at Google are very much worried that clients got themselves hacked (since not all clients are managed tightly), and are pushing rogue code.  \n\nIf however, an adversary is already in the position to control what goes on inside the Git/Gerrit server, then we\u0027re already in a very bad place.",
      "parentUuid": "17cb370e_a672a843",
      "range": {
        "startLine": 30,
        "startChar": 13,
        "endLine": 31,
        "endChar": 27
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c779515c_46d13b11",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "Would le-git-imate also work with only this option?",
      "range": {
        "startLine": 53,
        "startChar": 45,
        "endLine": 53,
        "endChar": 53
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caf45f58_721dd041",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "If the tree is very large, it could take quite some time to walk through all of it. Have you tried the proposed implementation on large trees? If so, with which results?",
      "range": {
        "startLine": 53,
        "startChar": 34,
        "endLine": 53,
        "endChar": 43
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2f21d94_7db382c4",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 55,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "It would be good to define the returned data objects and their hierarchy.\n\nWhat I saw in the implementation so far for a tree entry:\n- SHA-1\n- Mode\n- Path\n- Type\n\nIs the \u0027path\u0027 the full path or just the \u0027name\u0027 within the directory?\n\nIs the \u0027mode\u0027 something you would need for le-git-imate?",
      "range": {
        "startLine": 55,
        "startChar": 35,
        "endLine": 55,
        "endChar": 51
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7dd18943_fb051fef",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1030912
      },
      "writtenOn": "2019-08-02T18:03:48Z",
      "side": 1,
      "message": "Do you have a use case in mind for which this would be helpful?",
      "range": {
        "startLine": 58,
        "startChar": 0,
        "endLine": 62,
        "endChar": 38
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1efbb63_d40e1089",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2019-07-19T20:06:32Z",
      "side": 1,
      "message": "Is this true even when using Git protocol\u0027s \u0027filter\u0027 feature (crbug.com/git/2)?",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 72,
        "endChar": 26
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7aa8c6b7_8e513f85",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-07-20T18:23:44Z",
      "side": 1,
      "message": "Yes, if we exclude filter options that need the server-side support (e.g, configs for the shallow clone),",
      "parentUuid": "f1efbb63_d40e1089",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 72,
        "endChar": 26
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d9f5fff9_2300af62",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 72,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2019-08-02T19:58:27Z",
      "side": 1,
      "message": "filter\u003dblob:none doesn\u0027t require any server-side setup. Likewise filter\u003dtree:0.",
      "parentUuid": "7aa8c6b7_8e513f85",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 72,
        "endChar": 26
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0a0e378b_138c01cc",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 83,
      "author": {
        "id": 1011842
      },
      "writtenOn": "2019-07-19T20:06:32Z",
      "side": 1,
      "message": "Hm, what complex functionality are you referring to?",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 83,
        "endChar": 21
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aaa3c077_96ee94d1",
        "filename": "pages/design-docs/tree-api-endpoint/doc.md",
        "patchSetId": 1
      },
      "lineNbr": 83,
      "author": {
        "id": 1084892
      },
      "writtenOn": "2019-07-20T18:23:44Z",
      "side": 1,
      "message": "Well, I would rephrase the statement as follows:\nit may be overkill to have to install a plugin\nwhile you need only a tiny portion of it (one simple API).",
      "parentUuid": "0a0e378b_138c01cc",
      "range": {
        "startLine": 83,
        "startChar": 0,
        "endLine": 83,
        "endChar": 21
      },
      "revId": "019a14198c2bf31cc7d397855a212b8282536096",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}